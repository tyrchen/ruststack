name: dynamodb-test

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
  workflow_dispatch:

jobs:
  dynamodb-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Start RustStack
        id: ruststack
        uses: tyrchen/ruststack@v0

      # ── Table Operations ─────────────────────────────────────────────
      - name: "Table Operations: create, describe, list, delete"
        run: |
          set -euo pipefail

          # Create a table with composite key
          aws dynamodb create-table \
            --table-name test-table \
            --key-schema \
              AttributeName=pk,KeyType=HASH \
              AttributeName=sk,KeyType=RANGE \
            --attribute-definitions \
              AttributeName=pk,AttributeType=S \
              AttributeName=sk,AttributeType=S \
            --billing-mode PAY_PER_REQUEST

          # Describe the table
          DESC=$(aws dynamodb describe-table --table-name test-table)
          echo "$DESC" | jq -r '.Table.TableStatus' | grep -q "ACTIVE"
          echo "$DESC" | jq -r '.Table.TableName' | grep -q "test-table"
          echo "$DESC" | jq -r '.Table.BillingModeSummary.BillingMode' | grep -q "PAY_PER_REQUEST"

          # Create a simple hash-only table
          aws dynamodb create-table \
            --table-name test-hash-only \
            --key-schema AttributeName=id,KeyType=HASH \
            --attribute-definitions AttributeName=id,AttributeType=S \
            --billing-mode PAY_PER_REQUEST

          # List tables
          TABLES=$(aws dynamodb list-tables)
          echo "$TABLES" | jq -r '.TableNames[]' | grep -q "test-table"
          echo "$TABLES" | jq -r '.TableNames[]' | grep -q "test-hash-only"

          # Delete table and verify
          aws dynamodb delete-table --table-name test-hash-only
          TABLES_AFTER=$(aws dynamodb list-tables)
          ! echo "$TABLES_AFTER" | jq -r '.TableNames[]' | grep -q "test-hash-only"

      # ── Item CRUD ────────────────────────────────────────────────────
      - name: "Item CRUD: put, get, update, delete"
        run: |
          set -euo pipefail

          # PutItem
          aws dynamodb put-item \
            --table-name test-table \
            --item '{
              "pk": {"S": "user#1"},
              "sk": {"S": "profile"},
              "name": {"S": "Alice"},
              "age": {"N": "30"},
              "active": {"BOOL": true},
              "tags": {"SS": ["admin", "user"]}
            }'

          # GetItem
          ITEM=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#1"}, "sk": {"S": "profile"}}')
          echo "$ITEM" | jq -r '.Item.name.S' | grep -q "Alice"
          echo "$ITEM" | jq -r '.Item.age.N' | grep -q "30"

          # GetItem with ProjectionExpression
          PROJECTED=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#1"}, "sk": {"S": "profile"}}' \
            --projection-expression "#n, age" \
            --expression-attribute-names '{"#n": "name"}')
          echo "$PROJECTED" | jq -r '.Item.name.S' | grep -q "Alice"
          # Should not contain 'tags' in projected result
          [ "$(echo "$PROJECTED" | jq '.Item.tags // empty')" = "" ]

          # UpdateItem with expressions
          aws dynamodb update-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#1"}, "sk": {"S": "profile"}}' \
            --update-expression "SET age = :new_age, email = :email" \
            --expression-attribute-values '{
              ":new_age": {"N": "31"},
              ":email": {"S": "alice@example.com"}
            }'

          UPDATED=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#1"}, "sk": {"S": "profile"}}')
          echo "$UPDATED" | jq -r '.Item.age.N' | grep -q "31"
          echo "$UPDATED" | jq -r '.Item.email.S' | grep -q "alice@example.com"

          # UpdateItem with ReturnValues
          RETURNED=$(aws dynamodb update-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#1"}, "sk": {"S": "profile"}}' \
            --update-expression "SET age = :new_age" \
            --expression-attribute-values '{":new_age": {"N": "32"}}' \
            --return-values ALL_NEW)
          echo "$RETURNED" | jq -r '.Attributes.age.N' | grep -q "32"

          # DeleteItem with ReturnValues
          DELETED=$(aws dynamodb delete-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#1"}, "sk": {"S": "profile"}}' \
            --return-values ALL_OLD)
          echo "$DELETED" | jq -r '.Attributes.name.S' | grep -q "Alice"

          # Verify item is gone
          GONE=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#1"}, "sk": {"S": "profile"}}')
          [ "$(echo "$GONE" | jq '.Item // empty')" = "" ]

      # ── Condition Expressions ────────────────────────────────────────
      - name: "Condition Expressions: conditional put/update/delete"
        run: |
          set -euo pipefail

          # Put an item
          aws dynamodb put-item \
            --table-name test-table \
            --item '{
              "pk": {"S": "user#2"},
              "sk": {"S": "profile"},
              "name": {"S": "Bob"},
              "version": {"N": "1"}
            }'

          # Conditional put (should fail — item already exists)
          ERR=$(aws dynamodb put-item \
            --table-name test-table \
            --item '{
              "pk": {"S": "user#2"},
              "sk": {"S": "profile"},
              "name": {"S": "Charlie"}
            }' \
            --condition-expression "attribute_not_exists(pk)" 2>&1 || true)
          echo "$ERR" | grep -qi "ConditionalCheckFailed"

          # Conditional update with version check (optimistic locking)
          aws dynamodb update-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#2"}, "sk": {"S": "profile"}}' \
            --update-expression "SET #n = :name, version = :new_v" \
            --condition-expression "version = :curr_v" \
            --expression-attribute-names '{"#n": "name"}' \
            --expression-attribute-values '{
              ":name": {"S": "Bobby"},
              ":new_v": {"N": "2"},
              ":curr_v": {"N": "1"}
            }'

          ITEM=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "user#2"}, "sk": {"S": "profile"}}')
          echo "$ITEM" | jq -r '.Item.name.S' | grep -q "Bobby"
          echo "$ITEM" | jq -r '.Item.version.N' | grep -q "2"

      # ── Query ────────────────────────────────────────────────────────
      - name: "Query: key conditions, filters, pagination"
        run: |
          set -euo pipefail

          # Insert test data
          for i in $(seq 1 20); do
            aws dynamodb put-item \
              --table-name test-table \
              --item "{
                \"pk\": {\"S\": \"order#100\"},
                \"sk\": {\"S\": \"item#$(printf '%03d' $i)\"},
                \"price\": {\"N\": \"$((i * 10))\"},
                \"category\": {\"S\": \"$([ $((i % 2)) -eq 0 ] && echo 'electronics' || echo 'books')\"}
              }"
          done

          # Query by partition key
          RESULT=$(aws dynamodb query \
            --table-name test-table \
            --key-condition-expression "pk = :pk" \
            --expression-attribute-values '{":pk": {"S": "order#100"}}')
          COUNT=$(echo "$RESULT" | jq '.Count')
          [ "$COUNT" -eq 20 ]

          # Query with sort key condition (begins_with)
          RESULT=$(aws dynamodb query \
            --table-name test-table \
            --key-condition-expression "pk = :pk AND begins_with(sk, :prefix)" \
            --expression-attribute-values '{
              ":pk": {"S": "order#100"},
              ":prefix": {"S": "item#01"}
            }')
          # Should match item#010..item#019 (items 10-19) and item#01 (1 item) = 11 items
          COUNT=$(echo "$RESULT" | jq '.Count')
          [ "$COUNT" -eq 11 ]

          # Query with filter expression
          RESULT=$(aws dynamodb query \
            --table-name test-table \
            --key-condition-expression "pk = :pk" \
            --filter-expression "category = :cat" \
            --expression-attribute-values '{
              ":pk": {"S": "order#100"},
              ":cat": {"S": "electronics"}
            }')
          COUNT=$(echo "$RESULT" | jq '.Count')
          [ "$COUNT" -eq 10 ]

          # Query with limit and pagination
          PAGE1=$(aws dynamodb query \
            --table-name test-table \
            --key-condition-expression "pk = :pk" \
            --expression-attribute-values '{":pk": {"S": "order#100"}}' \
            --limit 5)
          [ "$(echo "$PAGE1" | jq '.Count')" -eq 5 ]
          LAST_KEY=$(echo "$PAGE1" | jq -c '.LastEvaluatedKey')
          [ "$LAST_KEY" != "null" ]

          # Fetch next page
          PAGE2=$(aws dynamodb query \
            --table-name test-table \
            --key-condition-expression "pk = :pk" \
            --expression-attribute-values '{":pk": {"S": "order#100"}}' \
            --limit 5 \
            --exclusive-start-key "$LAST_KEY")
          [ "$(echo "$PAGE2" | jq '.Count')" -eq 5 ]

          # Query with ScanIndexForward=false (reverse order)
          RESULT=$(aws dynamodb query \
            --table-name test-table \
            --key-condition-expression "pk = :pk" \
            --expression-attribute-values '{":pk": {"S": "order#100"}}' \
            --no-scan-index-forward \
            --limit 3)
          FIRST_SK=$(echo "$RESULT" | jq -r '.Items[0].sk.S')
          [ "$FIRST_SK" = "item#020" ]

      # ── Scan ─────────────────────────────────────────────────────────
      - name: "Scan: full scan, filter, limit"
        run: |
          set -euo pipefail

          # Full scan
          RESULT=$(aws dynamodb scan --table-name test-table)
          COUNT=$(echo "$RESULT" | jq '.Count')
          echo "Total items in table: $COUNT"
          [ "$COUNT" -gt 20 ]

          # Scan with filter
          RESULT=$(aws dynamodb scan \
            --table-name test-table \
            --filter-expression "begins_with(pk, :prefix)" \
            --expression-attribute-values '{":prefix": {"S": "order#"}}')
          COUNT=$(echo "$RESULT" | jq '.Count')
          [ "$COUNT" -eq 20 ]

          # Scan with limit
          RESULT=$(aws dynamodb scan \
            --table-name test-table \
            --limit 5)
          [ "$(echo "$RESULT" | jq '.Count')" -le 5 ]

      # ── Batch Operations ─────────────────────────────────────────────
      - name: "Batch Operations: batch write, batch get"
        run: |
          set -euo pipefail

          # BatchWriteItem — put 10 items
          ITEMS=""
          for i in $(seq 1 10); do
            ITEMS="$ITEMS{\"PutRequest\":{\"Item\":{\"pk\":{\"S\":\"batch#1\"},\"sk\":{\"S\":\"item#$i\"},\"data\":{\"S\":\"value$i\"}}}},"
          done
          ITEMS="${ITEMS%,}"

          aws dynamodb batch-write-item \
            --request-items "{\"test-table\": [$ITEMS]}"

          # BatchGetItem — fetch 5 of them
          KEYS=""
          for i in 1 3 5 7 9; do
            KEYS="$KEYS{\"pk\":{\"S\":\"batch#1\"},\"sk\":{\"S\":\"item#$i\"}},"
          done
          KEYS="${KEYS%,}"

          RESULT=$(aws dynamodb batch-get-item \
            --request-items "{\"test-table\": {\"Keys\": [$KEYS]}}")
          GOT=$(echo "$RESULT" | jq '.Responses["test-table"] | length')
          [ "$GOT" -eq 5 ]

          # BatchWriteItem — delete items
          DELETES=""
          for i in $(seq 1 10); do
            DELETES="$DELETES{\"DeleteRequest\":{\"Key\":{\"pk\":{\"S\":\"batch#1\"},\"sk\":{\"S\":\"item#$i\"}}}},"
          done
          DELETES="${DELETES%,}"

          aws dynamodb batch-write-item \
            --request-items "{\"test-table\": [$DELETES]}"

          # Verify all deleted
          RESULT=$(aws dynamodb query \
            --table-name test-table \
            --key-condition-expression "pk = :pk" \
            --expression-attribute-values '{":pk": {"S": "batch#1"}}')
          [ "$(echo "$RESULT" | jq '.Count')" -eq 0 ]

      # ── Update Expressions ───────────────────────────────────────────
      - name: "Update Expressions: SET, REMOVE, ADD, DELETE"
        run: |
          set -euo pipefail

          # Create test item
          aws dynamodb put-item \
            --table-name test-table \
            --item '{
              "pk": {"S": "expr#1"},
              "sk": {"S": "test"},
              "counter": {"N": "0"},
              "tags": {"SS": ["a", "b", "c"]},
              "data": {"M": {"nested": {"S": "value"}}},
              "items": {"L": [{"S": "first"}, {"S": "second"}]}
            }'

          # SET — update multiple attributes
          aws dynamodb update-item \
            --table-name test-table \
            --key '{"pk": {"S": "expr#1"}, "sk": {"S": "test"}}' \
            --update-expression "SET counter = counter + :inc, new_attr = :val" \
            --expression-attribute-values '{
              ":inc": {"N": "5"},
              ":val": {"S": "hello"}
            }'

          ITEM=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "expr#1"}, "sk": {"S": "test"}}')
          echo "$ITEM" | jq -r '.Item.counter.N' | grep -q "5"
          echo "$ITEM" | jq -r '.Item.new_attr.S' | grep -q "hello"

          # ADD — increment counter and add to set
          aws dynamodb update-item \
            --table-name test-table \
            --key '{"pk": {"S": "expr#1"}, "sk": {"S": "test"}}' \
            --update-expression "ADD counter :inc, tags :new_tags" \
            --expression-attribute-values '{
              ":inc": {"N": "3"},
              ":new_tags": {"SS": ["d", "e"]}
            }'

          ITEM=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "expr#1"}, "sk": {"S": "test"}}')
          echo "$ITEM" | jq -r '.Item.counter.N' | grep -q "8"
          TAGS_COUNT=$(echo "$ITEM" | jq '.Item.tags.SS | length')
          [ "$TAGS_COUNT" -eq 5 ]

          # DELETE — remove elements from set
          aws dynamodb update-item \
            --table-name test-table \
            --key '{"pk": {"S": "expr#1"}, "sk": {"S": "test"}}' \
            --update-expression "DELETE tags :remove_tags" \
            --expression-attribute-values '{":remove_tags": {"SS": ["a", "b"]}}'

          ITEM=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "expr#1"}, "sk": {"S": "test"}}')
          TAGS_COUNT=$(echo "$ITEM" | jq '.Item.tags.SS | length')
          [ "$TAGS_COUNT" -eq 3 ]

          # REMOVE — remove attributes
          aws dynamodb update-item \
            --table-name test-table \
            --key '{"pk": {"S": "expr#1"}, "sk": {"S": "test"}}' \
            --update-expression "REMOVE new_attr, #d" \
            --expression-attribute-names '{"#d": "data"}'

          ITEM=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "expr#1"}, "sk": {"S": "test"}}')
          [ "$(echo "$ITEM" | jq '.Item.new_attr // empty')" = "" ]
          [ "$(echo "$ITEM" | jq '.Item.data // empty')" = "" ]

      # ── Data Types ───────────────────────────────────────────────────
      - name: "Data Types: all DynamoDB types"
        run: |
          set -euo pipefail

          aws dynamodb put-item \
            --table-name test-table \
            --item '{
              "pk": {"S": "types#1"},
              "sk": {"S": "test"},
              "string_val": {"S": "hello"},
              "number_val": {"N": "42.5"},
              "binary_val": {"B": "SGVsbG8gV29ybGQ="},
              "bool_true": {"BOOL": true},
              "bool_false": {"BOOL": false},
              "null_val": {"NULL": true},
              "string_set": {"SS": ["a", "b", "c"]},
              "number_set": {"NS": ["1", "2", "3"]},
              "list_val": {"L": [{"S": "item1"}, {"N": "42"}, {"BOOL": true}]},
              "map_val": {"M": {"key1": {"S": "val1"}, "nested": {"M": {"deep": {"N": "99"}}}}}
            }'

          ITEM=$(aws dynamodb get-item \
            --table-name test-table \
            --key '{"pk": {"S": "types#1"}, "sk": {"S": "test"}}')
          echo "$ITEM" | jq -r '.Item.string_val.S' | grep -q "hello"
          echo "$ITEM" | jq -r '.Item.number_val.N' | grep -q "42.5"
          [ "$(echo "$ITEM" | jq '.Item.bool_true.BOOL')" = "true" ]
          [ "$(echo "$ITEM" | jq '.Item.bool_false.BOOL')" = "false" ]
          [ "$(echo "$ITEM" | jq '.Item.null_val.NULL')" = "true" ]
          [ "$(echo "$ITEM" | jq '.Item.string_set.SS | length')" -eq 3 ]
          [ "$(echo "$ITEM" | jq '.Item.number_set.NS | length')" -eq 3 ]
          [ "$(echo "$ITEM" | jq '.Item.list_val.L | length')" -eq 3 ]
          echo "$ITEM" | jq -r '.Item.map_val.M.nested.M.deep.N' | grep -q "99"

      # ── Error Handling ───────────────────────────────────────────────
      - name: "Error Handling: validation errors"
        run: |
          set -euo pipefail

          # ResourceNotFoundException — table doesn't exist
          ERR=$(aws dynamodb get-item \
            --table-name nonexistent-table \
            --key '{"id": {"S": "1"}}' 2>&1 || true)
          echo "$ERR" | grep -qi "ResourceNotFoundException\|resource not found\|Cannot do operations"

          # ValidationException — missing key attribute
          ERR=$(aws dynamodb put-item \
            --table-name test-table \
            --item '{"pk": {"S": "test"}}' 2>&1 || true)
          echo "$ERR" | grep -qi "ValidationException\|validation"

          # ConditionalCheckFailedException
          aws dynamodb put-item \
            --table-name test-table \
            --item '{"pk": {"S": "err#1"}, "sk": {"S": "test"}, "val": {"S": "original"}}'
          ERR=$(aws dynamodb put-item \
            --table-name test-table \
            --item '{"pk": {"S": "err#1"}, "sk": {"S": "test"}, "val": {"S": "replaced"}}' \
            --condition-expression "attribute_not_exists(pk)" 2>&1 || true)
          echo "$ERR" | grep -qi "ConditionalCheckFailed"

      # ── Cleanup ──────────────────────────────────────────────────────
      - name: "Cleanup: delete test tables"
        if: always()
        run: |
          set -uo pipefail

          for TABLE in test-table; do
            echo "Deleting $TABLE ..."
            aws dynamodb delete-table --table-name "$TABLE" 2>/dev/null || true
          done

          echo "Cleanup complete."
